import { type KeyedTemplateResolver, type KeyedTemplateDirective, type TemplateOptimizationResult } from '../resolver/template-resolver';
import { type KeyValueMap, type AnyObject } from '../resolver/basic-types';
import { type PropertyLookupStep, GetNestedValueDirective } from './lookup';
import { type ValueWrapper } from './typing';
/**
 * Acts as a wrapper for the steps needed to complete a set of scripted actions.
 * @interface
 * @property {unknown[]} steps - actions to be performed
 */
export interface MultiStepParams {
    steps: unknown[];
}
/**
 * Covers the details of any item that may have triggered early termination of a set of scripted actions.
 * @interface
 * @property {unknown} args - target argument list
 */
export interface MultiStepDirectiveExit {
    directiveId: string;
    value: unknown;
}
/**
 * This directive executes a predetermined sequence of directive requests until it reaches the end of that list or runs into a recognized termination directive.
 * @class
 * @implements {KeyedTemplateDirective<MultiStepParams>}
 * @property {string[]} exitIds - list of directive ids that should be recognized as termination directives
 */
export declare class MultiStepDirective implements KeyedTemplateDirective<MultiStepParams> {
    readonly exitIds: string[];
    constructor(exitIds?: string[]);
    processParams(params: KeyValueMap, context: KeyValueMap, resolver: KeyedTemplateResolver): MultiStepParams;
    execute(params: KeyValueMap, context: KeyValueMap, resolver: KeyedTemplateResolver): unknown;
    /**
     * Processes the provided set of directive requests for a given context.
     * @function
     * @param {unknown[]} steps - actions to be executed
     * @param {KeyValueMap} context - extra data to be made available for resolution
     * @param {KeyedTemplateResolver} resolver - template resolver to be used
     * @returns {Partial<MultiStepDirectiveExit>} information on what action triggered an early termination (object is empty if script completed normally)
     */
    runSteps(steps: unknown[], context: KeyValueMap, resolver: KeyedTemplateResolver): Partial<MultiStepDirectiveExit>;
}
/**
 * These directives return a predetermined value each time they're executed.
 * These can be treated as constants or used as minimalist placeholder directives.
 * @class
 * @implements {KeyedTemplateDirective}
 * @property {unknown} value - value to be returned on execution of this directive
 */
export declare class SignalDirective implements KeyedTemplateDirective {
    readonly value: unknown;
    constructor(value?: unknown);
    execute(params: KeyValueMap, context: KeyValueMap, resolver: KeyedTemplateResolver): unknown;
    optimizeTemplate(params: KeyValueMap, resolver: KeyedTemplateResolver): TemplateOptimizationResult;
}
/**
 * These act as wrappers for another value, returning the resolved version of the value on execution.
 * They're primarily used to attach a directive marker to particular value without modifying it.
 * @class
 * @implements {KeyedTemplateDirective<IfThenFork>}
 */
export declare class ReturnValueDirective implements KeyedTemplateDirective<ValueWrapper> {
    processParams(params: KeyValueMap, context: KeyValueMap, resolver: KeyedTemplateResolver): ValueWrapper;
    execute(params: KeyValueMap, context: KeyValueMap, resolver: KeyedTemplateResolver): unknown;
    optimizeTemplate(params: KeyValueMap, resolver: KeyedTemplateResolver): TemplateOptimizationResult;
}
/**
 * Priority values for determining how to handle requests to end LoopingDirective execution.
 * @enum {number}
 */
export declare enum LoopingDirectiveExitPriority {
    /** ignore value, used to signal no exit should take place */
    NONE = 0,
    /** signals the current pass should end but be immediately followed by the next pass */
    BREAK_PASS = 1,
    /** signals both current and further iteration should end */
    EXIT_LOOP = 2,
    /** signals both that iteration should end and that the triggering action should override the default return value */
    RETURN_VALUE = 3
}
/**
 * Adds a priority rating to MultiStepDirectiveExit data.
 * @interface
 * @property {LoopingDirectiveExitPriority} priority - indicates how the exit should be handled by the loop
 */
export interface LoopingDirectiveExit extends MultiStepDirectiveExit {
    priority: LoopingDirectiveExitPriority;
}
/**
 * Base class for directives that repeat a given sequence of actions until certain conditions are met.
 * @class
 * @implements {KeyedTemplateDirective<IfThenFork>}
 */
export declare class LoopingDirective extends MultiStepDirective {
    readonly exitPriorities: Record<string, LoopingDirectiveExitPriority>;
    constructor(exitPriorities?: Record<string, LoopingDirectiveExitPriority>);
    /**
     * Cycles through the provided steps and prioritizes any exit signal generated by that pass.
     * The exit signal handling is primarily what distinguishes it from runSteps, though it does also ensure other exit data is initialized.
     * @function
     * @param {unknown[]} steps - actions to be executed
     * @param {KeyValueMap} context - extra data to be made available for resolution
     * @param {KeyedTemplateResolver} resolver - template resolver to be used
     * @returns {Partial<MultiStepDirectiveExit>} information on what action triggered an early termination (object is empty if script completed normally)
     */
    runPass(steps: unknown[], context: KeyValueMap, resolver: KeyedTemplateResolver): LoopingDirectiveExit;
}
/**
 * Adds iteration target and return value to MultiStepParams.
 * @interface
 * @property {unknown} for - iteration target
 * @property {unknown} return - value to return if iteration completes normally
 */
export interface IterationParams extends MultiStepParams {
    for: unknown;
    return: unknown;
}
/**
 * This directive repeats the provided steps over each item in the target collection.
 * This iteration uses a local context with a '$value' variable and either an '$index' or '$key' variable, depending on whether or not the collection is an array.
 * @class
 * @implements {KeyedTemplateDirective<LoopingDirective>}
 */
export declare class IterationDirective extends LoopingDirective {
    constructor(exitPriorities?: Record<string, LoopingDirectiveExitPriority>);
    processParams(params: KeyValueMap, context: KeyValueMap, resolver: KeyedTemplateResolver): IterationParams;
    execute(params: KeyValueMap, context: KeyValueMap, resolver: KeyedTemplateResolver): unknown;
}
/**
 * Adds a rate, range, and return value to MultiStepParams for iterating over said range.
 * @interface
 * @property {number} from - starting position for iteration
 * @property {number} to - ending positon for iteration
 * @property {number} rate - amount to adjust iteration value on each pass
 * @property {unknown} return - value to return if iteration completes normally
 */
export interface RepetitionParams extends MultiStepParams {
    from: number;
    to: number;
    rate: number;
    return: unknown;
}
/**
 * This directive repeats the provided steps for numbers within a given range.
 * This iteration uses a local context with an '$index' variable for the current value.
 * @class
 * @implements {KeyedTemplateDirective<IfThenFork>}
 */
export declare class RepetitionDirective extends LoopingDirective {
    processParams(params: KeyValueMap, context: KeyValueMap, resolver: KeyedTemplateResolver): RepetitionParams;
    execute(params: KeyValueMap, context: KeyValueMap, resolver: KeyedTemplateResolver): unknown;
    /**
     * Tries to convert the resolved version of the target value to a number.
     * @function
     * @param {unknown} value - value to be resolved and converted
     * @param {KeyValueMap} context - extra data to be made available for resolution
     * @param {KeyedTemplateResolver} resolver - template resolver to be used
     * @param {number} defaultValue - number to use if resolved value is not a number
     * @returns {number} converted value
     */
    resolveNumber(value: unknown, context: KeyValueMap, resolver: KeyedTemplateResolver, defaultValue?: number): number;
    /**
     * Iterates over the provided range.  This includes adjusting the iteration rate to the range's direction.
     * @function
     * @param {number} startIndex - starting position for iteration
     * @param {number} endIndex - ending positon for iteration
     * @param {(index: number) => boolean | undefined} callback - Callback to be performed for each iterated value.  Aborts execution if this returns false.
     * @param {number} rate - amount to adjust iteration value on each pass
     */
    forRange(startIndex: number, endIndex: number, callback: (index: number) => boolean | undefined, rate?: number): void;
}
/**
 * Specifies the path to a given nested value and what it should be set to.
 * @interface
 * @property {unknown[]} path - steps to the value's destination
 * @property {unknown} value - value to be stored
 */
export interface SetLocalValueParams {
    path: unknown[];
    value: unknown;
}
/**
 * This directive tries to assign a value to a particular path within the current context's local variables.
 * @class
 * @implements {KeyedTemplateDirective<SetLocalValueParams>}
 */
export declare class SetLocalValueDirective implements KeyedTemplateDirective<SetLocalValueParams> {
    protected _getter: GetNestedValueDirective;
    processParams(params: KeyValueMap, context: KeyValueMap, resolver: KeyedTemplateResolver): SetLocalValueParams;
    execute(params: KeyValueMap, context: KeyValueMap, resolver: KeyedTemplateResolver): void;
    /**
     * Attaches the provided value to a property of the target object.
     * @function
     * @param {AnyObject} target - object value should be attached to
     * @param {PropertyLookupStep} step - indicates how the value should be assigned
     * @param {unknown} value - value to be assigned
     */
    setObjectProperty(target: AnyObject, step: PropertyLookupStep, value: unknown): void;
    /**
     * Inserts the provided value into the target array.
     * @function
     * @param {AnyObject} target - array value should be inserted into
     * @param {PropertyLookupStep} step - indicates how the value should be inserted
     * @param {unknown} value - value to be inserted
     */
    setArrayItem(target: unknown[], step: PropertyLookupStep, value: unknown): void;
}
